---
layout: post
title: "Why Learn Haskell?"
tags: [haskell]
comments: true
---

As developers, there is so much we can learn to improve our skills, ranging from deep theory, to small practical tidbits of information. It can be overwhelming at times and we are forced to pick what we want to learn deeply and what we just want to gloss over. You can't learn it all!

My belief is that in terms of _long term_ improvement, learning [Haskell](https://www.haskell.org/) is one of the best ways to up your raw programming ability.

<img class="center-image" width="400" src="https://i.imgflip.com/537cg3.jpg" alt="Haskell meme"/>

## Why Learn any new Language

Learning a new programming language is a great way to improve as a programmer. Each language has its own unique take on things and will have some great ideas.

I ended up working in Ruby for a few years when at the time I was much more interested in working in Scala. I was sad about this at the time. However, I saw many cool things about Ruby and it ended up teaching me a lot. For example, I had not done strict TDD before which is very popular in Ruby. I learnt the pros and cons of this approach and I can now apply it well when needed.

Usually these new learnings are not strictly tied to the new language. You can take them and use them in many different programming languages.

<img class="center-image" width="400" src="https://i.imgflip.com/537dq5.jpg" alt="Haskell meme"/>

## Ok but why Learn Haskell

When learning a new programming language, it is usually best to choose some language that is very different from your known programming languages. For example, if you know Ruby you probably wouldn't get a huge amount out of learning Python, as they are quite similar.

Haskell is very different from mainstream popular programming languages in a few ways.

<img class="center-image" width="400" src="https://i.imgflip.com/537g0e.jpg" alt="Haskell meme"/>

### Functional Programming

Haskell is a purely functional programming (FP) language.

* It uses FP from the ground up. The whole ecosystem builds on these concepts, so you can't avoid them.
* It is pure. It does not have unconstrained side effects, so you need to learn the FP way of handling them.
* It's implementation closely mirrors the math behind FP, so you are learning something close to the real concepts.

Haskell actually inspired a lot of the [FP implementations](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/) in more popular languages. So knowing FP in Haskell will make these simpler implementations easy to understand. You will also understand the background of it and how it is supposed to be used.

<img class="center-image" width="400" src="https://i.imgflip.com/537fk6.jpg" alt="Haskell meme"/>

### Static Type Checking

Haskell builds on [type theory](https://en.wikipedia.org/wiki/Type_theory) and has an advanced type checker. This includes 'type-level' programming, or code that is run by the compiler at compile time, not at run time.

TODO link to type checkers

Like how many mainstream languages are getting FP features, they are also getting (more sophisiticated) type checkers. Again, if you are learn Haskell these simpler type systems should be easy to use.

<img class="center-image" width="400" src="https://i.imgflip.com/537gu8.jpg" alt="Haskell meme"/>

## You Can Use Haskell In Prod

There are even fancier languages than Haskell. Not more advanced in all ways, but that take a specific idea and go much further than Haskell. Notably, Idris and Agda. However, you can't really use these langauges in prod. Either because they are too immature, or they aren't really designed for it.

Haskell on the other hand is a sweet spot where it is highly advanced, but you can (and many companies do) use it in prod.

This means:

* You can learn Haskell by building real things.
* One day you might be able to just use Haskell directly, not do FP in OO languages ;)

## Expect Some Friction

## Haskell Is Fun

<img class="center-image" width="400" src="https://i.imgflip.com/537i18.jpg" alt="Haskell meme"/>
